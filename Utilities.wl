(* ::Package:: *)

SetOptions[EvaluationNotebook[], CellContext -> Notebook];
Get["EDCRGTCcode.m"] (* Riemann Geometry Tensor Calculus *);
On[Assert];


Clear[Coord, Parameters];
Coord={t, x, y, z};
Parameters={Qtt, Qxx, Qyy, Qzz, Qxz, \[Psi], \[Phi]1, \[Chi]1};


Clear[ParameterQ, CoordQ];
ParameterQ[s_] := MemberQ[Parameters, s];
CoordQ[s_] := MemberQ[Coord, s];


Clear[RewritePowerAsTimes, RepeatedRewrite];
RepeatedRewrite[expr_, f_] :=
    Map[Replace[#, x_ :> f[x]]&, expr /. {x_ :> f[x]}, Infinity];

RewritePowerAsTimes[x_] := x;
RewritePowerAsTimes[x_^(-1)] := CircleTimes[1, x];
RewritePowerAsTimes[x_^n_Integer] :=
    Module[{t = CirclePlus @@ Table[x, {i, Abs[n]}]},
        If[n > 0,
            t,
            CircleTimes[1, t]
        ]
    ] /; Abs[n] > 1;


Clear[RewriteParameter];
RewriteParameter[xx_] := xx;
RewriteParameter[Derivative[nx_Integer, nz_Integer][s_?ParameterQ][xx_?CoordQ, zz_?NumberQ]] :=
    RewriteParameter[Derivative[nx, nz][s][xx, z]];
RewriteParameter[Derivative[nx_Integer, nz_Integer][s_?ParameterQ][x_?CoordQ, z_?CoordQ]] :=
    Apply[
        Symbol[Join[Table["D", nx + nz]] <> "Q"],
        Join[
            {batch},
            Table[FirstPosition[Coord, x][[1]] - 1, nx],
            Table[FirstPosition[Coord, z][[1]] - 1, nz],
            {FirstPosition[Parameters, s][[1]] - 1}
        ]
    ];
RewriteParameter[s_?ParameterQ[x_?CoordQ, z_?CoordQ | z_?NumberQ]] :=
    Q[batch, FirstPosition[Parameters, s][[1]] - 1];


Clear[PrepareForHalide];
PrepareForHalide[expression_] :=
    Module[{t},
        t = expression;
        t = RepeatedRewrite[t, RewritePowerAsTimes];
        t = N[t];
        t = t /. {\[Mu] -> mu, \[Theta] -> theta};
        t = RepeatedRewrite[t, RewriteParameter];
        t = t /. {x -> x[batch], y -> y[batch], z -> z[batch]};
        t = ExportString[t, "Text", CharacterEncoding -> "ASCII"];
        StringReplace[t,
            { "(+)" -> "*", "(x)" -> "/",
              "[" -> "(", "]" -> ")",
              "batch" -> "i...",
              "Cos" -> "cos", "Sin" -> "sin"
            }
        ]
    ];


Clear[RewriteElementAsMacro, RewriteAsMacro];

RewriteElementAsMacro[name_, indices_, expression_] :=
    StringTemplate["    ``(i..., ``) = ``"][name, StringJoin[Riffle[ToString /@ (indices - 1), ", "]], PrepareForHalide[expression]];
    
RewriteAsMacro[name_String, expression_] :=
    "#define FROM_EXPRESSIONS_" <> name <> "(dEsTiNaTiOn) \\\n" <>
        "    dEsTiNaTiOn(i...) = " <> PrepareForHalide[expression];
RewriteAsMacro[name_String, expression_List] :=
    Module[{indices, strings},
        indices = SparseArray[expression]["NonzeroPositions"];
        strings = RewriteElementAsMacro["dEsTiNaTiOn", #, Part[expression, Sequence @@ #]]& /@ indices;
        "#define FROM_EXPRESSIONS_" <> name <> "(dEsTiNaTiOn) \\\n" <>
            StringJoin[Riffle[strings, "; \\\n"]]
    ];


Clear[generateHeader];
generateHeader[tensors_List, append_] :=
    Module[{t, m},
        t = NotebookDirectory[] <> "metric/kernels/generated_expressions.hpp";
        Print[t];
        t = If[append,
            OpenAppend[t]
            ,
            OpenWrite[t]
        ];
        If[Not[append],
            WriteString[t,
                "// WARNING: DO NOT EDIT\n" <>
                    "// This file is automatically generated by Mathematica.\n" <>
                    "// Edit the corresponding Mathematica Notebooks instead.\n\n" <>
                    "#pragma once\n\n"
            ]
        ];
        Do[
            WriteString[t, Apply[RewriteAsMacro, p] <> "\n\n"],
            {p, tensors}
        ];
        Close[t];
    ]


Clear[getSmallestPower];
getSmallestPower[x_SeriesData] :=
    List @@ x[[4]];
    
Clear[getLeadingTerm];
getLeadingTerm[expression_SeriesData] :=
    SeriesCoefficient[expression, getSmallestPower[expression]];
    
Clear[getSubleadingTerm];
getSubleadingTerm[expression_SeriesData] :=
    SeriesCoefficient[expression, getSmallestPower[expression]+1];


Clear[minimalOrder, leadingOrderIsTrivial, constructHorizonBoundaryConditions,constructConformalBoundaryConditions];
minimalOrder[expr_] :=
    Series[expr, {z, 1, 2}];
    
leadingOrderIsTrivial[expr_] :=
    TrueQ[Simplify[getLeadingTerm[expr] /. {Qtt -> Qzz}] == 0];
    
constructHorizonBoundaryConditions[gdd_] :=
    Module[{Ad, Fdd, FUd, FUU, divFd, EOM\[Psi], \[Phi], \[Chi], V, DV\[Phi], DV\[Chi], GUddRef, \[Xi]U, \[Xi]d, div\[Xi]dd, covD\[Phi], covD\[Chi], Gdd, EOMQ, EOM\[Phi], EOM\[Chi], horizonQ},
        RGtensors[gdd, Coord, {1, 0, 0}];
        Ad = {(1 - z) \[Psi][x, z], 0, 0, 0};
        Fdd = (Transpose[#] - #&) @ minimalOrder[covD[Ad]] // Simplify;
        FUd = Raise[Fdd, {1}] // minimalOrder;
        FUU = Raise[FUd, {2}] // minimalOrder;
        divFd = covDiv[FUd, {1}] // minimalOrder;
        EOM\[Psi] = divFd[[1]] // Simplify;
        \[Phi] = z * \[Phi]1[x, z];
        \[Chi] = z * \[Chi]1[x, z];
        V = -2 (\[Phi]^2 + \[Chi]^2) / L^2;
        DV\[Phi] = -4 \[Phi] / L^2;
        DV\[Chi] = -4 \[Chi] / L^2;
        covD\[Phi] = covD[\[Phi]] // minimalOrder;
        covD\[Chi] = covD[\[Chi]] // minimalOrder;
        EOM\[Phi] = covDiv[Raise[covD\[Phi], {1}], {1}] - DV\[Phi] // minimalOrder // Simplify;
        EOM\[Chi] = covDiv[Raise[covD\[Chi], {1}], {1}] - DV\[Chi] // minimalOrder // Simplify;
        GUddRef = GUdd /. {Qtt -> (1&), Qzz -> (1&), Qxx -> (1&), Qyy -> (1&), Qxz -> (0&)}
             // minimalOrder // Simplify;
        \[Xi]U = multiDot[gUU, (GUdd - GUddRef), {1, 2}, {2, 3}] // minimalOrder;
        \[Xi]d = Lower[\[Xi]U, 1] // minimalOrder;
        div\[Xi]dd = (Transpose[#] + #) / 2& @ minimalOrder[covD[\[Xi]d]] // Simplify;
        Gdd = Rdd + (3 / L^2 - V) * gdd -
            2 (Outer[Times, covD\[Phi], covD\[Phi]] + Outer[Times, covD\[Chi], covD\[Chi]]) -
            (minimalOrder[multiDot[Fdd, Raise[Fdd, {2}], {2, 2}]] -
                gdd / 4 * minimalOrder[multiDot[Fdd, FUU, {1, 1}, {2, 2}]]
            );
        EOMQ = Gdd - div\[Xi]dd // minimalOrder // Simplify;
        horizon\[Psi] = getLeadingTerm[EOM\[Psi]] // Simplify;
        horizon\[Phi] = getLeadingTerm[EOM\[Phi]] // Simplify;
        horizon\[Chi] = getLeadingTerm[EOM\[Chi]] // Simplify;
        Assert[leadingOrderIsTrivial[EOMQ[[1, 1]]]];
        Assert[leadingOrderIsTrivial[EOMQ[[4, 4]]]];
        Assert[leadingOrderIsTrivial[EOMQ[[2, 4]]]];
        horizonQ = {getLeadingTerm[EOMQ[[1, 1]]] // Simplify,
            getLeadingTerm[EOMQ[[2, 2]]] // Simplify,
            getLeadingTerm[EOMQ[[3, 3]]] // Simplify,
            getSubleadingTerm[EOMQ[[4, 4]]] // Simplify,
            getSubleadingTerm[EOMQ[[2, 4]]] // Simplify
        };
        Join[horizonQ, {horizon\[Psi], horizon\[Phi], horizon\[Chi]}]
    ];
    
constructConformalBoundaryConditions[] :=
    Module[{conformalSubstitutions, params},
        conformalSubstitutions = {
            Qtt[x, z_] -> 1,
            Qxx[x, z_] -> 1,
            Qyy[x, z_] -> 1,
            Qzz[x, z_] -> 1,
            Qxz[x, z_] -> 0,
            \[Psi][x, z_] -> \[Mu],
            \[Phi]1[x, z_] -> Cos[\[Theta]] * V0 * Cos[k0 * x],
            \[Chi]1[x, z_] -> Sin[\[Theta]] * V0 * Sin[k0 * x]
        };
        params = #[x, z]& /@ Parameters;
        params - (params /. {z -> 0} /. conformalSubstitutions)
    ];


Clear[defaultGenerateHeader];
defaultGenerateHeader[] :=
    Module[{dCoord, ds, P, gdd, gUU, Ad, Fdd, \[Phi], \[Chi], V, DV\[Phi], DV\[Chi], Dgddd, DgdUU, DDgdddd, DFddd, D\[Phi]d, DD\[Phi]dd, D\[Chi]d, DD\[Chi]dd, GUddRef, DGdUddRef, conformal, horizon},
        dCoord = {dt, dx, dy, dz};
        P[z_] :=
            1 + z + z^2 - (\[Mu]^2 z^3) / 2;
        ds = (L^2) / z^2 (-(1 - z) P[z] Qtt[x, z] dt^2 + (Qzz[x, z] dz^2) / (P[z] (1 - z)) + Qxx[x, z] (dx + z^2 Qxz[x, z] dz)^2 + Qyy[x, z] dy^2);
        gdd = Map[Coefficient[ds, #]&, TensorProduct[dCoord, dCoord], {2}];
        gdd = UpperTriangularize[gdd];
        gdd = (gdd + Transpose[gdd]) / 2 // Simplify;
        RGtensors[gdd, Coord, {1, 0, 0}];
        gUU = Inverse[gdd]//Simplify;
        Ad = {(1 - z) \[Psi][x, z], 0, 0, 0};
        Fdd = (Transpose[#] - #&) @ covD[Ad] // Simplify;
        \[Phi] = z * \[Phi]1[x, z];
        \[Chi] = z * \[Chi]1[x, z];
        V = -2 (\[Phi]^2 + \[Chi]^2) / L^2;
        DV\[Phi] = -4 \[Phi] / L^2;
        DV\[Chi] = -4 \[Chi] / L^2;
        Dgddd = D[gdd, #]& /@ Coord // Simplify;
        DgdUU = D[gUU, #]& /@ Coord // Simplify;
        DDgdddd = D[Dgddd, #]& /@ Coord // Simplify;
        DFddd = D[Fdd, #]& /@ Coord // Simplify;
        D\[Phi]d = D[\[Phi], #]& /@ Coord // Simplify;
        DD\[Phi]dd = D[D\[Phi]d, #]& /@ Coord // Simplify;
        D\[Chi]d = D[\[Chi], #]& /@ Coord // Simplify;
        DD\[Chi]dd = D[D\[Chi]d, #]& /@ Coord // Simplify;
        GUddRef = GUdd /. {Qtt -> (1&), Qzz -> (1&), Qxx -> (1&), Qyy -> (1&), Qxz -> (0&)} // Simplify;
        DGdUddRef = D[GUddRef, #]& /@ Coord // Simplify;
        generateHeader[{
            {"g_dd", gdd},
            {"g_UU", gUU},
            {"Dg_ddd", Dgddd},
            {"Dg_dUU", DgdUU},
            {"DDg_dddd", DDgdddd},
            {"Gamma_Udd_ref", GUddRef},
            {"DGamma_dUdd_ref", DGdUddRef},
            {"F_dd", Fdd},
            {"DF_ddd", DFddd},
            {"DPhi_d", D\[Phi]d},
            {"DDPhi_dd", DD\[Phi]dd},
            {"DChi_d", D\[Chi]d},
            {"DDChi_dd", DD\[Chi]dd},
            {"V", V},
            {"DV_Phi", DV\[Phi]},
            {"DV_Chi", DV\[Chi]}
        }, False];
        conformal = constructConformalBoundaryConditions[];
        horizon = constructHorizonBoundaryConditions[minimalOrder[gdd]];
        generateHeader[{
            {"Conformal", conformal},
            {"Horizon", horizon}
        }, True];
    ]


(*defaultGenerateHeader[]*)
